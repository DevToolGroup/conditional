[规则引擎组件]
ifndef::sourcedir[:sourcedir: ../../main/java/group/devtool/conditional/documentation/]
ifndef::resourcedir[:resourcedir: ../../main/resources/]
= 规则引擎组件

[[背景]]
== 背景
在企业管理系统中，存在以下场景：

* 动态访问控制，资源的访问控制控制维度千差万别，简单的角色划分无法满足要求。引入规则引擎的话，可以将实际的业务对象传入规则引擎，业务人员根据业务对象配置访问控制权限，满足多变的访问控制要求。
* 积分赠送，在一些企业的推广营销活动时，总会制定一些积分额外赠送的优惠政策，这些政策不同时间不同地点都可能存在差异，同时又有一定的时效性，过期后又采用之前的规则。在此场景下相较于硬编码，规则引擎相对更加便捷。
* 信用风险控制、产品定价等等

基于以上场景，开发设计了 *conditional* 规则引擎组件，参考 Rete 算法实现，相较于优秀的Drools引擎，禁用了事实修改，新增，删除的场景，增加了输入参数定义，输出参数定义，约束规则引擎的行为，划分程序员与业务员的边界，降低规则复杂度，方便业务人员维护使用。

[[开始之前]]
== 开始之前

`在使用规则引擎之前，请一定要思考这些问题，明确你需要的究竟是什么`

*规则引擎到底解决了什么问题？*

_网络上关于规则引擎解决问题的一般描述：_

1. 规则引擎可以让业务人员自由改变业务规则，而不需要程序员参与。
2. 可降低复杂业务逻辑组件复杂性、降低应用程序的维护和可扩展性成本的组件

_以上问题的疑问_:

1. 不需要程序员参与，业务人员真的能够独立完成规则修改吗？
2. 规则引擎将业务逻辑抽离，那么代码又是用来解决什么问题的？
3. 维护规则的成本一定比维护程序的成本低吗？版本发布一定比规则发布的风险、管理难度大吗？
4. 业内还有脚本引擎，流程引擎，一定程度上也能实现业务编排，流程定义，他们是一样的吗？

_作者对于这些问题的思考：_

1. 规则引擎一定是由程序员结合实际业务需求，抽象出来的受限制的业务规则，交给业务人员改动。
2. 结合第一点，在有限的场景内，规则引擎相较于硬编码，能够比较简单的支持多维度，多条件，多变动的规则。同时，在以上几个例子也体现了规则引擎的另外一个优势，随着时间的推移，规则引擎能够比较简单的实现规则变动的记录，方便后续的追溯，如果硬编码的话，随着人员的流动，规则知识比较容易出现丢失。因此，在有限的范围内，维护规则的成本相对较小，也更方便追溯。
3. 脚本引擎，流程引擎与规则引擎，在一定范围内存在解决问题的交集，但是针对 Drools 一类的 rete 算法来说，规则引擎的主要特点：假设了存在部分规则相同，存在大量规则条件以及规则事实，在此基础上有更好的性能表现。原因是脚本引擎则需要对每个规则依次判断，而 rete 算法通过构造条件网络减少了规则判断。

[[快速开始]]
== 快速开始
[[环境准备]]
=== 环境准备
* Java版本： JDK 8
* http://maven.apache.org/[Apache Maven]
[[依赖配置]]

=== 依赖配置
在项目的 *pom.xml* 文件中增加以下maven配置
[source, XML]
----
<dependencies>
  <dependency>
    <groupId>group.devtool.conditional.engine</groupId>
    <artifactId>engine</artifactId>
    <version>1.0-SNAPSHOT</version>
  </dependency>
</dependencies>
----

[[实际场景]]
=== 实际场景
==== 积分赠送

规则表达式：
[source]
----
include::{resourcedir}/sendScore.rl[]
----

运行规则引擎
[source, JAVA, indent=0]
----
include::{sourcedir}/RunRuleEngineExample.java[]
----

验证结果：
[source]
----
预期赠送积分数量：100，实际赠送积分数量：100
预期赠送积分数量：500，实际赠送积分数量：500
----
[[规则语言]]
== 规则语言
=== 类型定义
类型定义的基本结构
[source]
----
TYPE <编码> <名称>
  <类型> <编码> <名称>
  ...
END
----
整个类型定义语句包含在 `TYPE` ... `END` 中间，

1. 类型的定义，紧跟在 `TYPE` 后，有 **编码**，**名称/说明** 两部分组成，
2. 属性的定义，包含：**类型**，**编码**，**名称/注释**，每行数据对应一个属性的定义，支持多个属性的定义
其中关于属性类型定义的说明：
1. 属性类型支持以下基本类型：`Integer` 、`Long` 、`Float` 、`Double` 、`Decimal` 、`Boolean` 、`String` 、`Time`、`List`、`Map`, 其中List，Map两种类型需要指定容器元素的类型，容器元素类型不支持List，Map的嵌套
2. 属性类型支持自定义类型

=== 输入定义
输入定义的基本结构
[source]
----
ARG <类型> <编码>, <类型> <编码>, ...
----
输入定义以 `ARG` 开头，`,` 分割，每个输入参数包含：**类型**、**编码**，
输入参数的定义支持 _多个_ 输入参数，其中每个输入参数的编码，对应输入参数（MAP结构）中的一个key

=== 输出定义
输出定义的基本结构
[source]
----
RETURN <类型> <编码>
----
输出定义以 `RETURN` 开头，输出参数包含：**类型**、**编码**，
输出参数的仅支持 _一个_ 输出参数，其中输出参数的编码，对应输出结果（MAP结构）中的一个key

=== 规则定义
规则定义的基本机构
[source]
----
IF
 user.id == order.userId && order.amount > 100 && order.amount < 500 && dayScore < 10000
THEN
 PUT(score, "score", 100)
END
----
整个规则定义语句包含在 `IF` ... `THEN`... `END` 中间，
 `IF` 语句之后定义条件表达式， `THEN` 语句之后定义规则动作。

__当多个规则命中之后，规则动作的执行逻辑按照从上往下的顺序，最后定义的动作被执行__


[[程序扩展]]
== 程序扩展

[[自定义规则定义存储]]
=== 自定义规则定义存储
当前规则定义的存储是通过文件名读取Resources文件中定义的规则，具体实现
[source]
----
include::{sourcedir}/ExampleResourceRuleClassService.java[]
----
如果采用数据库的方式，可以实现接口 <<RuleClassService>>， 在启动规则引擎时，通过 <<RuleInstanceServiceProvider>> 实现类实现规则加载器的注入。

[[自定义执行动作]]
=== 自定义执行动作
当前组件默认支持的动作，包括：

* `PUT`，Map结构赋值操作。示例：<<PUT(score, "score", 100)>>
* `ADD`，List结构增加元素操作。示例：<<ADD(score.histories, MAP("time", 1, "count", 200))>>
* `LIST`，List结构初始化。示例：<<LIST(1, 2, 3)>>
* `MAP`，Map结构初始化。示例：<<MAP("time", 1, "count", 200)>>
* `MAX`，比较两个数字的大小，返回最大值。示例：<<MAX(1, 2)>>
* `MIN`，比较两个数字的大小，返回最小值。示例：<<MIN(1, 2)>>
* `SUBS`，获取字符串的子串，返回子串。示例：<<SUBS("time", 2, 3)>>
* `ABS`，返回一个数字的绝对值。示例：<<ABS(1)>>
* `AT`，返回字符串指定位置的字符。示例：<<AT("time", 1)>>
* `IN`，判断字符串或者对象是否存在于字符串中，列表中或者Map中。示例：<<IN("time", "me")>>
* `LEN`，返回字符串的长度，列表的长度，Map的大小。示例：<<LEN("time")>>
* `LOWER`，字符串转小写。示例：<<LOWER("time")>>
* `UPPER`，字符串转大写。示例：<<UPPER("time")>>
* `ROUND`，返回一个四舍五入向上取整的整数。示例：<<ROUND(1.5)>>
* `TRIMS`，删除字符串前后的空格。示例：<<TRIMS(" 123 ")>>
* `FILTER`，过滤列表中元素属性值等于目标值。示例：<<FILTER(user.histories, "time", 1)>>
* `SUM`，列表中的数值求和。示例：<<SUM(LIST(1, 2, 3))>>
* `RETRIEVE`，返回列表中元素对应字段的值组成的列表。示例：<<RETRIEVE(user.histories, "count")>>
* `NOW`，返回当前时间。示例：<<NOW()>>

如果以上函数不满足要求，可以通过实现接口 `ConditionFunction<T>`，实现自定义方法。
示例代码：
[source, JAVA, indent=0]
----
include::{sourcedir}/CustomFunctionExample.java[]
----
说明：
自定义函数的注入，可通过执行规则引擎时作为参数参入。

[[自定义规则执行器]]
=== 自定义规则执行器
当前默认是采用RETE算法的规则执行器，可以针对不同的场景采用不同的规则执行器，例如采用解释模式。
如果要替换规则，需要：

* 继承抽象规则定义 `AbstractRuleClass` 实现方法 <<public ConditionClassGroup getConditionGroup()>>
* 继承抽象规则定义加载器 `AbstractRuleClassLoader` 实现方法 <<protected abstract AbstractRuleClass buildRuleClass()>>
* 实现接口 `RuleClassService`，完成规则定义的加载

完成以上初始化后，通过类 `RuleInstanceServiceProvider` 注入对应的规则定义服务。

[[遗留问题]]
== 遗留问题
=== 性能测试
目前暂为针对性的验证框架的性能数据，后续随着组件的迭代，逐渐增加。。。

=== 基本类型中的List，Map嵌套结构
目前暂不支持类似 `List<Map<String, List<>>>` 结构的嵌套类型定义
