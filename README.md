## Conditional 规则引擎

Conditional 规则引擎，参考 Rete 算法实现，相较于优秀的Drools引擎，禁用了事实修改，新增，删除的场景，增加了输入参数定义，输出参数定义，约束规则引擎的行为，划分程序员与业务员的边界，降低规则复杂度，方便业务人员维护使用。

### 规则引擎解决的问题：

1. 规则引擎可以让业务人员自由改变业务规则，而不需要程序员参与。
2. 可降低复杂业务逻辑组件复杂性、降低应用程序的维护和可扩展性成本的组件

### 解决问题的疑问：

1. 不需要程序员参与，业务人员真的能够独立完成规则修改吗？
2. 规则引擎将业务逻辑抽离，那么代码又是用来解决什么问题的？
3. 维护规则的成本一定比维护程序的成本低吗？版本发布一定比规则发布的风险、管理难度小吗？
4. 业内还有脚本引擎，流程引擎，一定程度上也能实现业务编排，流程定义，他们是一样的吗？

> 在使用规则引擎之前，请一定要思考以上这些问题，明确你需要的究竟是什么

### 以上问题的思考：

1. 规则引擎一定是由程序员结合实际业务需求，抽象出来的受限制的业务规则，交给业务人员改动。

   实际场景举例：

   - 动态访问控制。

     资源的访问控制控制维度千差万别，简单的角色划分无法满足要求时，将实际的业务对象传入规则引擎，业务人员根据业务对象配置访问控制权限，满足多变的访问控制要求。

     之前作者经历的一个项目需求：一个客户资源如果是战略客户，只有他的销售对接人员，对接人员领导，以及邀请到客户关系团队的成员可以访问该客户数据，其中成员在团队中的角色不同，能看到的内容，可执行的操作也不同，另外客户关系团队的成员可能随时调整。如果用代码实现以上逻辑，就需要硬编码的方式，在所有操作接口中判断用户的访问权限，如果后期团队角色要调整，数据字典发生变动，就需要将所有的访问控制代码调整一遍，同时还要考虑到历史的数据兼容，随着时间的推移，很难再明白访问控制的逻辑，但如果通过规则引擎，则可以通过编写访问控制规则，这样代码本身就相对轻量，访问控制规则也相对集中，更能明白整体的逻辑。

   - 商超积分规则。

     积分赠送的场景，首先通过代码的方式能够很好的进行控制和配置，即便积分总送涉及多个业务实体，例如：用户等级，用户是否会员，用户是否新用户，订单时间在一定范围内多倍积分等等，那么通过规则引擎的配置，实现不大改动动代码的情况下满足多变的营销需求。

   - B 端优惠定价规则。

   - 信用风险控制规则。

2. 结合第一点，在有限的场景内，规则引擎相较于硬编码，能够比较简单的支持多维度，多条件，多变动的规则。同时，在以上几个例子也体现了规则引擎的另外一个优势，随着时间的推移，规则引擎能够比较简单的实现规则变动的记录，方便后续的追溯，如果硬编码的话，随着人员的流动，规则知识比较容易出现丢失。因此，在有限的范围内，维护规则的成本相对较小，也更方便追溯。

3. 脚本引擎，流程引擎与规则引擎，在一定范围内存在解决问题的交集，但是针对 drools 一类的 rete 算法来说，规则引擎的主要特点：假设了存在部分规则相同，存在大量规则条件以及规则事实，有更好的性能表现，脚本引擎则需要对每个规则依次判断，而 rete 算法通过构造条件网络减少了规则判断。

### 规则语法

```
# 类型定义
TYPE History "积分历史"
  Time    publishTime "时间"
  Integer count       "积分数量"
END

# 类型定义
TYPE User "用户"
  Integer id              "用户ID"
  Integer score           "用户积分"
  List<History> histories "积分历史"
END

# 类型定义
TYPE Order "订单"
  User    user "用户"
  Integer amount "订单金额"
END

# 类型定义
TYPE Score "积分"
  Integer score "积分数量"
  List<History> histories "积分记录"
END

# 输入参数定义
ARG Order order, User user

# 输出参数定义
RETURN Score score

# 全局变量定义
CONST List<History> dayHistory "当日积分记录" = FILTER(user.histories, "time", now())
CONST Integer dayScore "当日积分数量" = SUM(RETRIEVE(dayHistory, "count"))

# 规则定义
# 如果消费金额小于100，不加积分
IF
  user.id == order.userId && order.amount < 100
THEN
  PUT(score, "score", 1)
END


# 如果消费金额小于500，并且累计积分小于10000，增加100积分
IF
  user.id == order.userId && order.amount > 100 && order.amount < 500 && dayScore < 10000
THEN
  PUT(score, "score", 100)
END


# 如果消费金额大于500，并且累计积分小于10000,增加500积分
IF
  user.id == order.userId && order.amount > 500 && dayScore < 10000
THEN
  PUT(score, "score", 500)
END
```

### 语法说明
1. 类型定义，主要目的是限制输入，输出参数类型
2. 输出参数是唯一可以修改的变量，但是不能作为条件，原因是规则引擎内部基于RETE算法，缓存了条件的判断结果，因此，如果作为条件，面临缓存失效的问题，进而影响引擎性能。如果需要更加灵活的表达式可以使用Groovy等脚本引擎。
3. 全局变量，主要目的：用来作为常量，或者缓存计算结果，方便后续判断条件使用。其中全局变量不支持修改，但是可以作为条件。
4. 动作定义，
5. 规则定义，
